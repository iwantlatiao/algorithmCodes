# 栈 总结

## AcWing 41. 包含min函数的栈

- 要求设计一个支持 push，pop，top 等操作并且可以在 `O(1)` 时间内检索出最小元素的堆栈。
- 如果同时维护一个二叉堆，复杂度为 `logN`。如果只维护一个最小值，就无法得知新的最小值是什么。
- 可以维护两个栈，A 栈存原本的数据，B 栈存栈 A 中从栈底到当前位置的最小值。每次 A 栈 push 时，B 栈插入 `min(data, B.top)`；pop时，B 栈也弹出。

## AcWing 128. 编辑器

- 要求实现一个编辑器，实现光标处插入、向左删除、向左移动、向右移动、计算光标处之前的最大前缀和五个操作。
- 可以通过对顶栈实现，两个栈分别维护光标前与后的数字。

## AcWing 129, 130. 火车进栈

- 见 [NOIP 2003 栈](../../../luogu_training_list/1-4_recursion/readme.md)

## AcWing 131. 直方图中最大的矩形

- 在一条水平线上有若干个矩形，求包含于这些矩形的最大矩形面积
- [@滑稽](https://www.acwing.com/solution/content/5569/)：首先考虑暴力做法，以每个矩形的高度为准，向两边扩展，直到遇到比它矮的为止。时间复杂度为 `O(N^2)`。本题也有分治做法，最大矩形只可能在最矮的矩形与最矮的左边与右边矩形之间产生，于是时间复杂度为 `O(NlogN)`。
- 单调栈的第 `i` 位可以维护 `ai` 后第一个大于或小于它的元素下标。我们使用递增的单调栈，从左往右扫。如果当前矩形比栈顶矩形高则入栈，否则，不断弹出栈顶，直至栈为空或者栈顶比当前高。在弹出过程中，需要累计连续弹出的宽度和。每弹出一个栈顶，就可以计算该栈顶周围的面积（宽度乘当前高度）。停止弹出时，再压入当前高度和累计宽度的新矩形。

```c++
a[n+1] = 0, p = 0;  // 在 n+1 位置放一个高为 0 的矩形作为边界
for (int i=1; i<=n+1; i++) {
    if (a[i] > s[p])  // 当前矩形比栈顶高 直接入栈
        s[++p] = a[i], w[p] = 1;
    else {  // 当前矩形比栈顶低 先弹栈到停然后入栈
        int width = 0;
        while (s[p] > a[i]) {
            width += w[p];
            ans = max(ans, width * s[p]);  // 弹的时候可以算答案
            p--;
        }
        s[++p] = a[i], w[p] = width + 1;  // 之前更高的高度不用考虑了，把新的矩形压回来
    }
}
```

- 单调栈的思想在于及时排除不可能的选项（如果当前矩形比栈顶小，那么该矩形面积也没法用到之前矩形更高的高度），保持策略的秩序，便于高效处理。