# 树状数组

[OI Wiki 对树状数组的介绍](https://oi-wiki.org/ds/fenwick)

[@Jeffery 树状数组入门指南](https://www.cnblogs.com/Jefferyz/p/18055621)

[@王超 树状数组的原理、结构 和 典型应用](https://writings.sh/post/binary-indexed-tree)

## 基本概念

回想把正整数分解乘二的不重复次幂的唯一分解性质。若一个数的二进制表示为 $a_{k-1}a_{k-2}\cdots a_{1}a_{0}$，其中等于 1 的位是 $\{ a_{i_1}, \cdots, a_{i_m} \}$，则正整数 x 可以被二进制分解为

$$
x = 2^{i_1} + 2^{i_2} + \cdots + 2^{i_m}
$$

不妨设 $i_1>\cdots > i_m$，这样区间 $[1,x]$ 可以被分为 $O(\log(x))$ 个长度递减的区间。

1. 长度为 $2^{i_1}$ 的区间： $[1, 2^{i_1}]$
2. 长度为 $2^{i_2}$ 的区间： $[2^{i_1} + 1, 2^{i_1} + 2^{i_2}]$
3. 长度为 $2^{i_3}$ 的区间： $[2^{i_1} + 2^{i_2} + 1, 2^{i_1} + 2^{i_2} + 2^{i_3}]$
4. ... 以此类推

所以给定 x 只要不断迭代倒着减区间长度，就可以倒着找到能刚好覆盖区间 $[1,x]$ 的所有子区间。x 的最短子区间长度其实就可以用 `lowbit(x) = x & (~x + 1) = x & (-x)` 计算得出。

```c++
// 计算 [1,x] 的所有子区间
while (x > 0) {
	printf("[%d, %d]\n", x - (x & -x) + 1, x);  // start, end
	x -= x & -x;
}
```

基于上述思想就有了树状数组（Binary Indexed Tree），基本用途是维护序列的前缀和。对于给定的序列 a，可以新建一个数组 c，其中 `c[x]` 保存闭区间 `a[x - lowbit(x) + 1] ~ a[x]` 所有数的和，可以用下图表示。

![OI Wiki 树状数组示意图](https://oi-wiki.org/ds/images/fenwick.svg)

该结构满足几个性质：

1. 节点 `c[x]` 保存以它为根的子树中所有叶节点的和
2. 节点 `c[x]` 覆盖了 a 中 `lowbit(x)` 个元素
3. 除了树根，节点 `c[x]` 的父节点是 `c[x + lowbit(x)]`（ `lowbit(x)` 体现了子节点二分了父节点的一个子区间）
4. 树的深度为 $O(\log n)$

树状数组支持两个基础操作：区间查询（从小区间到大区间）、单点修改（往父节点走）。

```c++
// 树状数组查询前缀和 ask(x) = c[1, x]
int ask(int x) {
	int ans = 0;
	for (; x; x -= x & -x) ans += c[x];
	return ans;
}
// 树状数组单点增加
void add(int x, int y) { for (; x <= N; x += x & -x) c[x] += y;}
```
在执行这些操作之前，我们还需要对树状数组做初始化，即对原始数列构造一个树状数组。最简单的初始化方法是直接建立一个全零的数组 `c` ，然后对于每个位置 `x` 执行 `add(x, a[x])` ，时间复杂度为 $O(n\log n)$ 。一般情况下已经够用。

还有两种 $O(n)$ 的建树方法。

```c++
// from OI Wiki
// 方法一：每一个节点的值是由所有与自己直接相连的儿子的值求和得到的。
// 因此可以倒着考虑贡献，即每次确定完儿子的值后，
// 用自己的值更新自己的直接父亲。
void init() {
    for (int i = 1; i <= n; ++i) {
        t[i] += a[i];
        int j = i + lowbit(i);
        if (j <= n) t[j] += t[i];
    }
}
// 方法二：由于树状数组维护了区间信息，所以可以预处理一个前缀和然后
// 根据定义赋值。
void init() {
    for (int i = 1; i <= n; ++i) 
        t[i] = sum[i] - sum[i - lowbit(i)];
}
```

## 树状数组与逆序对

逆序对问题一般有几种解法：

1. 朴素（枚举数组元素的所有组合）
2. 基于冒泡排序（每一次交换就会消除一个逆序对）
3. 基于插入排序（每次后方元素的移动就相当于一个逆序对）
4. 基于[归并排序](../../../template/sort.md/#merge-sort)（段内的逆序对交换不会影响段外的逆序对）
5. 基于树状数组。

接下来介绍基于树状数组的逆序对计算方法。

任意给定一个集合 `a` ，如果用 `t[val]` 来保存 `val` 在集合 `a` 中出现的次数，那么 `sum(t[l, r])` 就表示集合 `a` 在值域 `[l, r]` 有多少个数。而 `sum(t[l, r])` 可以用树状数组维护，这样就可以利用树状数组求逆序对个数了，思路如下：

1. 树状数组初始化全零，接下来将在序列 `a` 的值域维护一个树状数组。
2. 倒序扫描 `a` ，对于每个数 `a[i]`：（1）查询前缀和 `[1, a[i]-1]` 累加到答案 `ans` 中 （2）执行单点增加 `t[a[i]]++` 维护值域。
3. 执行完后，所有的逆序对数量为 `ans` 。

由于倒序扫描，所以已经在树状数组中的就是在 `a[i]` 后面的数。在第二步中，通过树状数组查询每个 `a[i]` 后面有多少个比它小的数。这样得到的结果之和当然就是逆序对个数。时间复杂度为 $O(N+M)\log M$ ，`M` 为值域大小。注意当值域较大时，需要先进行离散化。但是由于离散化本身就需要先排序，所以在这种情况下不如直接使用归并排序。



```c++
// 树状数组求逆序对
for (int i = n; i; i--) {
	ans += ask(a[i]);
	add(a[i], 1);
}
// 有时需要做离散化
memcpy(b, a, sizeof a);
sort(b + 1, b + 1 + n);
int cnt = unique(b + 1, b + 1 + n) - b - 1;
for (int i = 1; i <= n; i ++)
    a[i] = lower_bound(b + 1, b + 1 + cnt, a[i]) - b;
```

### acwing 241 楼兰图腾

题意：给一个长为 `N` 的数列。要求找到 `v` 形和 `^` 形的所有数量。`v` 形的定义是 `x1<x2<x3` 且 `y1>y2, y2<y3`。`N<2e5` 。

思路：

在树状数组求逆序对中，我们已经知道怎么求每个元素后面小于它的元素个数（倒叙扫描、`ask(val-1)`）。同理，可以求每个元素前面小于它的元素个数（正序扫描、`ask(val-1)`）、每个元素后面大于它的元素个数（倒序扫描、`ask(n) - ask(val)`）、每个元素前面大于它的元素个数（正序扫描、`ask(n) - ask(val)`）。

依次枚举每个点作为中心点， `v` 形的数量为前面大于它的元素个数乘后面大于它的元素个数， `^` 形同理。最后全加起来即可。

```c++
// @qiaoxinwei: https://www.acwing.com/solution/content/13818/
int main() {
    scanf("%d", &n); for(int i = 1; i <= n; i++) scanf("%d", &a[i]);
    //从左向右，依次统计每个位置左边比第i个数y小的数的个数、以及大的数的个数
    for(int i = 1; i <= n; i++) {
        int y = a[i]; 
        Lower[i] = ask(y - 1);
        Greater[i] = ask(n) - ask(y);
        add(y, 1);
    }
    //清空树状数组，从右往左统计每个位置右边比第i个数y小的数的个数、以及大的数的个数
    memset(t, 0, sizeof t); LL resA = 0, resV = 0;
    for(int i = n; i >= 1; i--) {
        int y = a[i];
        resA += (LL)Lower[i] * ask(y - 1);
        resV += (LL)Greater[i] * (ask(n) - ask(y));
        add(y, 1);
    }
    printf("%lld %lld\n", resV, resA); return 0;
}
```

## 区间修改、单点查询

树状数组支持的基本操作为区间查询、单点修改。如果要实现区间修改、单点查询，则需要换一种思路。下面以 [AcWing 242. 一个简单的整数问题](https://www.acwing.com/activity/content/problem/content/477/) 为例解释如何实现。

该题要求维护单点查询和区间增加。我们在输入的数组 `a` 外额外再新建一个数组 `b` 用来维护差分信息。对于每条指令 `add(l, r, d)` 将其转化为 `b[l] += d, b[r+1] -= d` 。这样操作后，考虑 `b` 数组的前缀和，可以发现 `[1, l)` 和 `(r, n]` 的前缀和都是不变的，但 `[l, r]` 的前缀和增加了 `d` 。

于是就可以用树状数组来维护 `b` 的前缀和。由于各次操作之间具有可累加性，所以先在树状数组上查询前缀和 `b[1~x]` 就得到了所有 `add` 操作在 `a[x]` 上增加的数值总和。再加上 `a[x]` 的原始值就得到了 `Query` 的答案。

实际上，通过维护数组 `b` ，我们把维护数列的具体值转化为维护指令的累计影响。影响的前缀和就表示了数值的变化情况。该做法将区间修改、单点查询转化为单点修改、区间查询。

## 区间修改、区间查询

以 [AcWing 243. 一个简单的整数问题2](https://www.acwing.com/activity/content/problem/content/478/) 为例，接下来需要实现区间修改、区间查询。

对单点查询 `a[x]` ，实际需要求的是经过一些指令后的变化量，即 `b` 的一个前缀和 `b[1~x]`。所以对于区间查询 `a[1~x]` ，实际求的是 `b` 的多个前缀和。为了便于计算，将其进行一定改写。（前面式子包含多个变量，我们希望公式中不同变量之间相互独立，这样就可以分别用树状数组维护）

$$
\sum_{i=1}^{x} \sum_{j=1}^{i} b[j] = \sum_{i=1}^{x} (x-i+1) * b[i] = (x+1) \sum_{i=1}^{x} b[i] - \sum_{i=1}^{x} i * b[i]
$$

可以发现前项是单点查询时已经维护的一个树状数组，所以只需要再增加一个树状数组维护 $\sum_{i=1}^{x} i * b[i]$ 即可。对于每条指令 `add(l, r, d)` 都将其转化为 `c0[l] += d` 、 `c0[r+1] -= d` 、 `c1[l] += l * d` 、 `c1[r+1] -= (r+1) * d` 。另外再建立 `sum` 数组存储 `a` 的原始前缀和，这样 `Query(l, r)` 就可以变为：

```c++
ans = (sum[r] + (r+1) * ask(c0, r) - ask(c1, r))
    - (sum[l-1] + l * ask(c0, l-1) - ask(c1, l-1));
```

参考代码如下：

```c++
long long ask(int k,int x) {
	long long ans=0;
	for(;x;x-=x&-x) ans+=c[k][x];
	return ans;
}

void add(int k,int x,int y) {
	for(;x<=n;x+=x&-x) c[k][x]+=y;
}

int main() {
	cin>>n>>m;
	for(int i=1;i<=n;i++) {
		scanf("%d",&a[i]);
		sum[i]=sum[i-1]+a[i];
	}
	while(m--) {
		char op[2]; int l,r,d;
		scanf("%s%d%d",op,&l,&r);
		if(op[0]=='C') {
			scanf("%d",&d);
			add(0,l,d);	add(0,r+1,-d);
			add(1,l,l*d); add(1,r+1,-(r+1)*d);
		}
		else {
			long long ans=sum[r]+(r+1)*ask(0,r)-ask(1,r);
			ans-=sum[l-1]+l*ask(0,l-1)-ask(1,l-1);
			printf("%lld\n",ans);
		}
	}
}
```

## 维护不可差分信息（如区间最值）

注意：虽然树状数组可以维护区间最值、并且代码量小，但单点修改和区间查询的复杂度均为 $O(\log ^2 n)$ ，大于线段树 $O(\log n)$ 。

### 区间查询

我们还是基于之前的思路，从 `r` 用 `lowbit` 一直向前跳，但是我们不能跳到 `l` 的左边。（如果要区间 `[5, 13]` 的最大值，根据树状数组结构，可以把区间分为 `[13, 13]` 、 `[9, 12]` 、 `[1, 8]` 。前两个好求，问题在于 `[1, 8]` 不能直接转换为 `[5, 8]` ）

因此如果下一步要跳 `c[x]` 就判断下一次要跳到的 `x-lowbit(x)` 是否小于 `l`。

1. 如果 `x-lowbit(x)>=l` 就说明下一次跳的没越界，正常合并 `c[x]` 然后下一步跳 `c[x-lowbit(x)]`
2. 如果 `x-lowbit(x)<l` 就说明下一次跳到左端点之外，这时只将 `a[x]` 单点合并，下一步跳 `c[x-1]`

```c++
int getmax(int l, int r) {
    int ans = 0;
    while (r >= l) {
        ans = max(ans, a[r]); --r;
        // 注意，循环条件不要写成 r - lowbit(r) + 1 >= l
        // 否则 l = 1 时，r 跳到 0 会死循环
        // 不过 r - lowbit(r) + 1 >= l && r > 0 好像也可以
        for (; r - lowbit(r) >= l; r -= lowbit(r))
            ans = max(ans, C[r]);
    }
    return ans;
}
```

### 单点更新

对于 `a[x] = p` ，一种常见的错误想法是直接修改所有相关节点 `x` 的祖先 `y` ，让 `c[y] = max(c[y], p)` 。反例是将 `1, 2, 3, 4, 5` 中的 `5` 改成 `4` ，会得到错误答案 `5` 。直接 `c[y] = p` 也是不正确的。

事实上，对于不可差分信息，不存在通过 `p` 直接修改 `c[y]` 的方式。这是因为修改本身就是相当于把旧数从原区间移除，然后加入一个新数。移除时对区间的影响就相当于逆运算，而不可差分信息不存在逆运算，所以不能直接修改 `c[y]` 。换句话说，我们需要重构所有受到影响的区间。

我们先引入两个性质，证明在 [OI Wiki 树状数组与其树形态的性质](https://oi-wiki.org/ds/fenwick/#%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84%E4%B8%8E%E5%85%B6%E6%A0%91%E5%BD%A2%E6%80%81%E7%9A%84%E6%80%A7%E8%B4%A8) 已给出，故此处省略。

1. 设 $u=s * 2^{k+1}+2^k$ ，则其儿子数量为 $k=\log_2 \mathrm{lowbit}(u)$ ，编号分别为 $u-2^t$ ，$0\leq t < k$ 。（即若 `u` 的二进制写法下最后一个 `1` 在第 `k` 位，则它就有 `k` 个儿子。假设 `u = ...1000` 则 `u` 就有三个儿子，二进制编号分别为 `...0111` 、 `...0110` 、 `...0100` ）
2. `u` 的所有儿子对应 `c` 的管辖区间恰好拼接成 `[l(u), u-1]` ，其中 `l(x)=x-lowbit(x)+1` 。

考虑 `c[y]` 的儿子们，它们的信息一定是正确的（先更新儿子再更新父亲）。而这些儿子恰好组成 `[l(y), y-1]` 这一段管辖区间。那么再合并一个单点 `a[y]` 就可以合并出 `[l(y), y]` 这一段，也就是 `c[y]` 。这样对于每一个 `c[y]` 都用它的儿子进行合并。

```c++
void update(int x, int v) {
    a[x] = v;
    for (int i = x; i <= n; i += lowbit(i)) {
        // 枚举受影响的区间
        C[i] = a[i];
        for (int j = 1; j < lowbit(i); j *= 2) 
            C[i] = max(C[i], C[i - j]);
    }
}
```

## 一些好题

### acwing 244 谜一样的牛

题意：有 n 头奶牛，已知它们的身高为 1 到 n 且各不相同，但不知道每头奶牛的具体身高。现在这 n 头奶牛站成一列，已知第 i 头牛前面有 Ai 头牛比它低，求每头奶牛的身高。

思路：

假设现在有 5 头奶牛，A 数组如下所示：

```
cow     a b c d e
A[i]    / 1 2 1 0
```

如果最后一头奶牛的前面有 k 头牛比它低，那么最后一头奶牛的身高应该是第 k+1 小。如此时 `A[5] = 0` 头牛比他低，那么最后一头奶牛的身高就可以确定是 `A[5] + 1 = 1` 。

```
cow     a b c d e
A[i]    / 1 2 1 0

height  1 2 3 4 5
        e ? ? ? ?
```

然后再看倒数第二头奶牛。因为 `A[4] = 1`，所以在除了奶牛 `e` 应该处于第二小的位置。

```
height  1 2 3 4 5
        e ? d ? ?
```

所以实际上每次安置奶牛 `i` 的位置是，从前往后数，跳过已经安置好的奶牛，的第 `A[i]+1` 个空位。为了方便维护，不妨设数组 `b[x]` 为零一数组，初始值均为 `1` ，含义是身高为 `x` 的奶牛是否已经安置（ `=1` 未安置； `=0` 已安置）。假设第 `i` 头奶牛满足 `A[i] = k` ，这样实际就是先找 `b` 数组的前缀和至少为 `k+1` 的左边界，然后将该位设为已安置。所以可以用树状数组进行维护。

#### 方法一：树状数组 + 二分，单次时间复杂度 $O(\log^2 n)$

```c++
for (int i = n; i >= 1; --i) {
    int l = 1, r = n;
    while (l < r) {
        int mid = (l + r) >> 1;
        if (ask(mid) < A[i] + 1) l = mid + 1;
        else r = mid;
    }
    height[i] = l;  // 第 i 头牛的高度为 l
    modify(l, -1);  // 置零
}
```

#### 方法二：树状数组 + 倍增，单次时间复杂度 $O(\log n)$

倍增的思想为 `以 2 的整数次幂为步长，能累加则累加` 。而树状数组恰好为我们维护了区间长度为 $2^x$ 的区间的信息。所以我们可以这样沿着树状数组查询：

1. 初始化两个变量，当前枚举到的位置 `ans=0` 和当前枚举到的位置的前缀和 `sum=0` 。
2. 从 $\lfloor \log n \rfloor \to 0$ 倒序考虑每个整数 `p` 。对于每个 `p` ，若 `ans + 2^p <= n` 且 `sum + c[ans + 2^p] < k + 1` ，则令 `sum += c[ans + 2^p]` （找到小于 `k+1` 的最右端点）
3. 最后 `height[i] = ans + 1` 即为所求

```c++
for (int i = n; i; i--) {
    int ans = 0, sum = 0;
    for (int j = t; j >= 0; j--)
        if (ans + p[j] <= n && sum + c[ans+p[j]] < a[i] + 1) {
            sum += c[ans+p[j]];
            ans += p[j];
        }
    add(h[i] = ans + 1);
}
```

### LIS 的树状数组 DP 优化

回忆 LIS 问题有[两种转移方程](https://leetcode.cn/problems/longest-increasing-subsequence/solutions/147667/zui-chang-shang-sheng-zi-xu-lie-by-leetcode-soluti/)：

```c++
1. dp[i] 表示前 i 个元素，以第 i 个数字结尾的 LIS 长度，且 nums[i] 必须被选取。
dp[i] = max(dp[j]) + 1, 0 <= j < i && num[j] < num[i];
ans = max(dp[i])
2. d[i] 表示长度为 i 的 LIS 的末尾元素最小值
```


## TODO

TODO：[LIS 的树状数组做法](https://writings.sh/post/find-number-of-lis)

[@lfool 线段树详解](https://leetcode.cn/problems/range-module/solutions/1612955/by-lfool-eo50/)