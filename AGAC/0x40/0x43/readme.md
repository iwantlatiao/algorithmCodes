# 0x43 线段树

[@lfool 线段树详解](https://leetcode.cn/problems/range-module/solutions/1612955/by-lfool-eo50/)

[OI wiki 对线段树的介绍](https://oi-wiki.org/ds/seg/)

## 基本概念

线段树是算法竞赛中常用的用来维护 **区间信息** 的数据结构。与按照二的次幂进行区间划分的树状数组相比，线段树是一种更加通用的结构。

线段树可以在 $O(\log N)$ 的时间复杂度内实现单点修改、区间修改、区间查询（区间求和、最值、GCD）等操作。

线段树具有以下几个性质：

1. 线段树的每个节点都代表一个区间。
2. 线段树具有唯一的根节点，代表整个统计区间。
3. 线段树的叶节点是长度为 1 的元区间。
4. 对于每个内部节点 `[l,r]` ，它的左子节点是 `[l,mid]` ，右子节点是 `[mid+1,r]` ，其中 `mid=(l+r)>>1` 。

可以发现，除了树的最后一层，整棵线段树是完全二叉树，树的深度为 $O(\log N)$ ，因此可以按照与二叉堆类似的 “父子二倍” 编号方法：

1. 根节点编号为 1
2. 编号为 `x` 的节点，左子节点的编号为 `x<<1` ，右子节点的编号为 `(x<<1)+1`

这样就可以用一个简单的 `struct` 来保存线段树了。由于最后一层不连续，所以用于保存线段树的数组长度要开到 `4*N` 才能保证不会越界。

### 建树

线段树的二叉树结构可以很方便地从下往上传递信息。建树时采用递归建树，如果根节点管辖的区间长度已经是 1，则可以直接根据相应位置的值初始化该节点。否则我们将该区间从中点处分割为两个子区间，分别进入左右子节点递归建树，最后合并两个子节点的信息。

```c++
struct SegmentTree {
    int l, r;
    int dat;
} t[SIZE * 4]; // struct数组存储线段树

// 以维护区间最大值为例建树
// 当前节点 t[p] 维护区间为 [1,n]
void build(int p, int l, int r) {
    t[p].l = l, t[p].r = r; // 节点p代表区间[l,r]
    if (l == r) { t[p].dat = a[l]; return; } // 叶节点
    int mid = (l + r) / 2; // 折半
    build(p*2, l, mid); // 左子节点[l,mid]，编号p*2
    build(p*2+1, mid+1, r); // 右子节点[mid+1,r]，编号p*2+1
    t[p].dat = max(t[p*2].dat, t[p*2+1].dat); // 从下往上传递信息
}
build(1, 1, n); // 调用入口
```

### 单点修改

修改是从下往上的。需要先从根节点出发，找到目标叶子节点，然后再从下往上更新所有父节点信息。

```c++
// 当前节点为 p，目标把 A[x] 修改为 v
void change(int p, int x, int v) {
	if (t[p].l == t[p].r) { t[p].dat = v; return; } // 找到叶节点
	int mid = (t[p].l + t[p].r) / 2;
	if (x <= mid) change(p*2, x, v); // x属于左半区间
	else change(p*2+1, x, v); // x属于右半区间
	t[p].dat = max(t[p*2].dat, t[p*2+1].dat); // 从下往上更新信息
}
change(1, x, v); // 调用入口，都是从根节点开始往下找再往上更新
```

### 区间查询

对区间 `[l,r]` 的查询可以分为三种情况：

1. 区间 `[l,r]` 完全覆盖了当前节点的区间，则当前节点是候选答案，立即回溯。
2. 左子节点与 `[l,r]` 有重叠部分，则递归访问左子节点
3. 右子节点与 `[l,r]` 有重叠部分，则递归访问右子节点

```c++
int ask(int p, int l, int r) {
	if (l <= t[p].l && r >= t[p].r) return t[p].dat; // 完全包含，直接返回
	int mid = (t[p].l + t[p].r) / 2;
	int val = 0;
	if (l <= mid) val = max(val, ask(p*2, l, r)); // 左子节点有重叠
	if (r > mid) val = max(val, ask(p*2+1, l, r)); // 右子节点有重叠
	return val;
}
cout << ask(1, l, r) << endl; // 调用入口
```

该查询过程会把询问区间 [l,r] 在线段树上分成 $O(\log N)$ 个节点。