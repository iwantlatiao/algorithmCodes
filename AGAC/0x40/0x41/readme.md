# 0x41 并查集

## 概念

[OI-Wiki 并查集介绍](https://oi-wiki.org/ds/dsu/)

[@Pecco 对并查集的介绍](https://zhuanlan.zhihu.com/p/93647900)

[先前做过部分有关并查集的题目](../../../luogu_training_list/2-3_set/readme.md)

并查集支持两种操作：

1. 合并（Union）：合并两个元素所属集合（合并对应的树）
2. 查询（Find）：查询某个元素所属集合（查询对应的树的根节点），这可以用于判断两个元素是否属于同一集合

并查集在经过修改后可以支持单个元素的**删除**（[HDU 2473](http://acm.hdu.edu.cn/showproblem.php?pid=2473)）、移动；使用动态开点线段树还可以实现可持久化并查集。

并查集常用两种优化方法：路径压缩与按秩合并。

1. 路径压缩：查询过程中经过的每个元素都属于该集合，我们可以将其直接连到根节点以加快后续查询。
2. 按秩合并：合并时，选择哪棵树的根节点作为新树的根节点会影响未来操作的复杂度。我们可以将节点较少或深度较小的树连到另一棵，以免发生退化。（注意，秩不是准确的子树高，而是子树高的上界，因为路径压缩可能改变子树高。还可以将秩定义成子树节点数，因为节点多的树倾向更高。无论将秩定义成子树高上界，还是子树节点数，按秩合并都是尝试合出最矮的树，并不保证一定最矮。）

如果只使用路径压缩的最坏时间复杂度是 $O(m\log n)$，平均情况下是 $O(m\alpha(m,n))$。只使用启发式合并，而不使用路径压缩，时间复杂度为 $O(m\log n)$。由于路径压缩单次合并可能造成大量修改，有时路径压缩并不适合使用。例如，在可持久化并查集、线段树分治 + 并查集中，一般使用只启发式合并的并查集。

```c++
void init(int n) { for(int i = 1; i <= n; ++i) fa[i] = i; }
void merge(int i, int j) { fa[find(i)] = find(j); }

// 路径压缩
int find(int x) { return x == fa[x] ? x : (fa[x] = find(fa[x])); }  

// 按秩合并
void init(int n) { for(int i = 1; i <= n; ++i) fa[i] = i, rank[i] = 1; }
void merge(int i, int j) {
    int x = find(i), y = find(j);  // 先找到两个根节点
    if (rank[x] <= rank[y]) fa[x] = y;
    else fa[y] = x;
    // 如果深度相同且根节点不同，则新的根节点的深度 + 1
    if (rank[x] == rank[y] && x != y) rank[y]++;                   
}
```

## acwing 237 程序自动分析

