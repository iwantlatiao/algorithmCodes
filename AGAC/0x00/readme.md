# 基础算法总结

## [116. 飞行员兄弟](https://www.acwing.com/problem/content/118/)

“飞行员兄弟”这个游戏，需要玩家顺利的打开一个拥有 16 个把手的冰箱。已知每个把手可以处于以下两种状态之一：打开或关闭。只有当所有把手都打开时，冰箱才会打开。把手可以表示为一个 4×4 的矩阵，您可以改变任何一个位置上把手的状态。但是，这也会使得第 i 行和第 j 列上的所有把手的状态也随着改变。

请你求出打开冰箱所需的切换把手的次数最小值是多少。

### 思路

- 观察到数据范围小，可以枚举（二进制或递归）每一个切换把手的动作。
- 对比 [洛谷P10449 费解的开关](https://www.luogu.com.cn/problem/P10449) ，本题改变一个把手状态会改变行和列，而费解的开关只改变行，所以费解的开关枚举第一行的状态即可枚举所有可能，而本题需要对所有状态进行枚举。

## [117. 占卜DIY](https://www.acwing.com/problem/content/119/)

一道抽牌模拟题，发现需要维护一个双端队列，于是可以用 `deque`。可以使用 `pair<int,int>` 维护牌号和是否朝上，然而好像一张牌不会翻两次，所有就没有维护。

## [118. 分形](https://www.acwing.com/problem/content/120/)

画分型，如下：

```c++
// level 1
X
// level 2
X X
 X
X X
// level B(n-1)
B(n - 1)        B(n - 1)

        B(n - 1)

B(n - 1)        B(n - 1)
```

### 思路

- 观察可得，当 $n\geq 2$ 时输出可以看为九宫格，其中左上、右上、中间、左下、右下是上一层的输出。
- 然后就可以先把每一层所占的格子计算出来，然后把 $n\leq 7$ 的情况均输出即可。

## [119. 袭击](https://www.acwing.com/problem/content/121/)

- 原始的 [平面最近点对问题](https://oi-wiki.org/geometry/nearest-points/) 可见 [洛谷P7883 平面最近点对](https://www.luogu.com.cn/problem/P7883)。
- 如果选点后内部再快速排序，复杂度为两个 `log`。然而第一次按 `xy` 排序后选完点就不需要这个排序结果了，所以可以内部重新按 `y` 归并排序，复杂度变为一个 `log`。
- 本题为分为两组的平面最近点对。我们需要在每个点上记录类型，如果两个点的类型相同，在计算时将这两个点的距离制为正无穷。但是会带来一个问题：如果 `[l, r)` 中全是同类型的点，在计算来自分别左右两个区间 `[l, mid)`，`[mid, r)` 的点的最小距离时，依然会枚举所有可能的点对。这是因为对于返回距离无穷大的时候，我们并不能通过 `x` 坐标差大于计算的当前最小值来跳出循环，因为当前最小值一定为无穷大。所以可以在开始迭代之前算一个距离当作最小距离。
- 另外，相同的点且坐标相同的点不需要加入计算的数组中，不同的点且坐标相同的点直接输出结果，因为没有比这个更小的距离了，其他的点照常加入计算数组中。
- （这个好像不对）最方便且比较快的[做法](https://www.acwing.com/problem/content/discussion/content/8211/)其实不用归并排序，只需要每次在分治后取左边和右边各6个点，然后计算距离，最多算36次，`n=2e5` 时 `T(n)~=1e6`。

## [120. 防线](https://www.acwing.com/problem/content/122/)

- 本题给定 `n` 个等差数列，整个序列中至多有一个位置所占数字是奇数。判断奇数位是否存在并求位置。
- 参考[墨染空的思路](https://www.acwing.com/solution/content/2545/)，可以使用前缀和 + 二分位置的方法实现 `nlogn` 级别的复杂度。整个序列中至多有一个位置的数字所占数量是奇数，所以如果存在奇数位，则整个数列的总和必然是奇数，故二分区间计算区间的和是否为奇数即可。然后可以用前缀和 `sum(l,r) = sum[r] - sum[l]` 求区间的和。
- 需要在线性时间内求出 `sum[x]` 。方法是枚举每一个等差数列，对每个数列可以用 `O(1)` 计算前缀和，所以求一次前缀和是线性时间的。
- 起点为 `s` 终点为 `e` 差为 `d` 的等差数列，对前缀和 `sum[x]` 的贡献取决于在区间 `[s, min(e, x)]` 中有多少长为 `d` 的段，所以每枚举一个数列前缀和就累加 `sum[x] += floor((min(e, x) - s // d)) + 1` 。

## [121. 赶牛入圈](https://www.acwing.com/problem/content/123/)

- 本题给定 `N` 个平面上的点（其实是 `1x1` 的小正方形），求能包含 `C` 个点的最小的正方形。坐标绝对值小于 `1e4`，点数小于 `500`。
- [思路](https://www.acwing.com/solution/content/1091/)：首先直接遍历坐标不可行，但是看点数不多，可以先离散化然后再用二维前缀和做二分判定。
- 本题还有一个细节，点是有大小的。所以在算正方形边长的时候需要加一。具体判断如下

```c++
bool check(int len) {
    // 找第一个不在 len 区间内的 x1 与 y1，然后用二维前缀和判定可行性
    for (int x1 = 0, x2 = 1; x2 < numbers.size(); x2++) {
        while (numbers[x2] - numbers[x1 + 1] + 1 > len) x1++;
        for (int y1 = 0, y2 = 1; y2 < numbers.size(); y2++) {
            while (numbers[y2] - numbers[y1 + 1] + 1 > len) y1++;
            if (sum[x2][y2] - sum[x1][y2] - sum[x2][y1] + sum[x1][y1] >= C) return true;
        }
    }
    return false;
}
```

## [122. 糖果传递](https://www.acwing.com/problem/content/124/)

- 本题为环形纸牌均分问题模板，类似题目 [acwing105七夕祭](https://www.acwing.com/problem/content/107/)
- [思路](https://www.acwing.com/solution/content/41677/)在于如何把纸牌均分问题转化为前缀和，以及如何把环形的问题变为链式的问题。
- 涉及到求中位数，其实有 $O(n)$ 算法（BFPTR），不过直接排序也可以。

## [123. 士兵](https://www.acwing.com/problem/content/125/)

- 本题要求通过移动士兵使得所有士兵的 `x` 坐标相邻，`y` 坐标相同。
- 直觉可以得到 `y` 坐标用 `y` 的中位数，如果 `x` 坐标也能用中位数，那就可以分别求中位数得到答案了。但 `x` 坐标相邻如何[证明](https://www.acwing.com/solution/content/2392/)是用 `x` 的中位数呢？

假设所有 `x` 坐标从左到右排序 `x1, x2, ... xn`，且排序后最左边坐标为 `a`，那么移动次数的表达式为 `|x1-a|, |x2-(a+1)|, ..., |xn-(a+(n-1))|`。
整理可得需要让这个式子的和最小 `|(x1)-a|, |(x2+1)-a|, ..., |(xn+n-1)-a|`，所以当 `a` 为 `x1，x2+1，..., xn+n-1` 的中位数时取得最小。
所以本题分别用两次 `sort` 求得 `y` 和 `x1，x2+1，..., xn+n-1` 的中位数，然后计算次数即可。

## [124. 数的进制转换](https://www.acwing.com/problem/content/126/)