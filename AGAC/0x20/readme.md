# 深搜

## acwing 166 数独

数独 是一种传统益智游戏，你需要把一个 9×9 的数独补充完整，使得数独中每行、每列、每个 3×3 的九宫格内数字 1∼9 均恰好出现一次。请编写一个程序填写数独。

### 思路

- 对于每行、每列、每个九宫格分别用一个 9 位二进制数代表哪些数还可以填（二进制的与运算，然后用 lowbit 取能填的数字）
- 填上（删去）某个数后就要对二进制数的某位改成零（一）

# 剪枝

## acwing 167 木棒

乔治拿来一组等长的木棒，将它们随机地砍断，使得每一节木棍的长度都不超过 50 个长度单位。然后他又想把这些木棍恢复到为裁截前的状态，但忘记了初始时有多少木棒以及木棒的初始长度。

请你设计一个程序，帮助乔治计算木棒的可能最小长度。每一节木棍的长度都用大于零的整数表示。

### 思路

[@tonngw](https://www.acwing.com/solution/content/121003/)

剪枝策略：

1. sum % length = 0
2. 木棍长度降序排序，以组合方式枚举搜索
3. 如果当前长度木棍没有搜到方案，跳过该长度
4. 如果木棒的第一根木棍就搜索失败，则一定搜不到方案。（交换可证）
5. 如果木棒的最后一根木棍搜索失败，则一定搜不到方案。（贪心可证）

```c++
// 正在拼第 stick 根木棍，该木棍当前长度 cab，从 start 开始枚举木棍序号 
bool dfs(int stick, int cab, int start) {
    if (stick > cnt) return true;  // 全拼好了
    if (cab == nowlen) return dfs(stick + 1, 0, 1);  // 拼下一根

    int fail = 0;  // 上一根失败的长度
    for (int i = start; i <= n; i++) {
        if (!vis[i] && fail != sticks[i] && cab + sticks[i] <= nowlen) {
            vis[i] = true;
            if(dfs(stick, cab + sticks[i], i + 1)) return true;
            vis[i] = false; fail = sticks[i];
            if (cab == 0 || cab + sticks[i] == nowlen) return false;
        }
    }

    return false;
}
```

## acwing 168 生日蛋糕

制作一个体积为 $N\pi$ 的 $M$ 层生日蛋糕，每层都是一个圆柱体。设从下往上数第 $i$ 层蛋糕是半径为 $Ri$，高度为 $Hi$ 的圆柱。当 $i<M$ 时，要求 $Ri>Ri+1$ 且 $Hi>Hi+1$。

我们希望蛋糕外表面（最下一层的下底面除外）的面积 $Q$ 最小。令 $Q=S\pi$ ，请编程对给出的 $N$ 和 $M$，找出蛋糕的制作方案（适当的 $Ri$ 和 $Hi$ 的值），使 $S$ 最小。除 $Q$ 外，以上所有数据皆为正整数。

### 剪枝思路

[@random_srand](https://www.acwing.com/solution/content/31876/)

记最底层为 $m$，则有表面积和体积公式：

$$
S_{total} = \sum_{i=1}^{m}(2\pi R_i H_i) \\
V_{total} = \sum_{i=1}^{m}(\pi R_i^2 H_i)
$$

优化搜索顺序：层间从下到上；层内先枚举半径再枚举高，从大到小

可行性剪枝：记总体积为 $n$，总层数为 $m$，当前层 $u$，第 $u$ 层的体积为 $V_u$，半径 $R_u$，体积 $V_u$，第 $m$ 层到第 $u+1$ 层的体积和为 $V$，面积和为 $S$。

1. 半径限制：最小取值应该是当前层号，最大取值取决于下一层半径减一或当前层体积最大值除高度最小值。

$$u\leq R_u\leq min\{R_{u+1}-1,\sqrt{\frac{n-min\sum_{i=1}^{u-1}V_i-V}u}\}$$

2. 高度限制：最小取值应该是当前层号，最大取值取决于下一层高度减一或当前层体积最大值除底面积最小值。

$$u\leq H_u\leq min\{H_{u+1}-1,\frac{n-min\sum_{i=1}^{u-1}V_i-V}{R_u^2}\}$$

3. 体积剪枝：已搜索体积加剩下的最小体积应该小于等于 $n$

$$V+min\sum_{i=1}^{u-1}V_i\leq n$$

4. 表面积和体积之间的关系

第一层到第 $u$ 层的表面积有（以下均省去 $\pi$）

$$S_{1-u}=2\sum_{i=1}^uR_iH_i=\frac2{R_{u+1}}\sum_{i=1}^uR_{u+1}R_iH_i>\frac2{R_{u+1}}\sum_{i=1}^uR_i^2H_i$$

第一层到第 $u$ 层体积有

$$n-V=\sum_{i=1}^uR_i^2H_i$$

所以有

$$S_{1-u}>\frac{2(n-V)}{R_{u+1}}$$

由于当前答案 $S_{now} = S + S_{1-u}$，已记录最佳答案 $S_{ans}$，如果 $S_{1-u}$ 的下界加 $S$ 都比最佳答案 $S_{ans}$ 大，就可以剪枝掉，即剪枝条件为

$$S+\frac{2(n-V)}{R_{u+1}}>=S_{ans}$$

5. 表面积剪枝：显然当前答案应该小于最佳答案

$$\sum_{i=u}^m S_i + \min{\sum_{i=1}^{u-1} S_i} < S_{ans}$$

### 搜索思路

```c++
// 当前层次 u 当前体积和 v 当前面积和 s
void dfs(int u, int v, int s) {
    if (...) return;                    // 剪枝

    if (u == 0) {
        if (v == n) res = s;
        return;
    }

    for (int r = rmax; r >= rmin; r--) {
        for (int h = hmax; h >= hmin; h--) {
            H[u] = h, R[u] = r;
            int t = u == m ? r * r : 0;  // 最底层加上表面面积
            dfs(u - 1, v + r * r * h, s + 2 * r * h + t);
        }
    }
}
```

## acwing 169 数独2

请你将一个 16×16 的数独填写完整，使得每行、每列、每个 4×4 十六宫格内字母 A∼P 均恰好出现一次。保证每个输入只有唯一解决方案。

### 思路

[@Lee2004](https://www.acwing.com/solution/content/4271/)

总体思路：每次找到一个空格，枚举空格选择哪个字母，然后往下递归。直到所有空格都填完。

对每个位置保存一个 16 位的二进制数，存储可以填的数字。每次递归之前，把这 256 个二进制数的状态进行保存，还原时直接恢复即可。

然后有很多剪枝：

1. 对于每个空格，如果不能填任何一个字母，则无解；如果只能填一个字母，那么直接填上;
2. 对于每一行，如果某个字母不能出现在任何一个位置，则无解；如果某个字母只有一个位置可以填，则直接填上；
3. 对于每一列，同2；
4. 对于每个16宫格，同2；
5. 每次选择空格时，选择备选方案(能填的字母数量)最少的格子来填。

# 广搜

## acwing 174 推箱子

推箱子游戏相信大家都不陌生，在本题中，你将控制一个人把 1 个箱子到目的地。

给定一张 N 行 M 列的地图，用字符 . 表示空地，字符 # 表示墙，字符 S 表示人的起始位置，字符 B 表示箱子的起始位置，字符 T 表示箱子的目标位置。

求一种移动方案，使箱子移动的次数最少，在此基础上再让人移动的总步数最少。

方案中使用大写的 EWSN（东西南北）表示箱子的移动，使用小写的 ewsn（东西南北）表示人的移动。

![acwing 174 pic](https://cdn.acwing.com/media/article/image/2019/01/16/19_8c8e5b0a19-%E6%8E%A8%E7%AE%B1%E5%AD%90.jpg)

### 思路

