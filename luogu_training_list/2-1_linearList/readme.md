# 2-1 线性表总结

## P3156	【深基15.例1】询问学号

按数组索引查询

## P3613	【深基15.例2】寄包柜

超市里有 $n(1\le n\le10^5)$ 个寄包柜。每个寄包柜格子数量不一，第 $i$ 个寄包柜有 $a_i(1\le a_i\le10^5)$ 个格子，不过我们并不知道各个 $a_i$ 的值。对于每个寄包柜，格子编号从 1 开始，一直到 $a_i$。现在有 $q(1 \le q\le10^5)$ 次操作：

- `1 i j k`：在第 $i$ 个柜子的第 $j$ 个格子存入物品 $k(0\le k\le 10^9)$。当 $k=0$ 时说明清空该格子。
- `2 i j`：查询第 $i$ 个柜子的第 $j$ 个格子中的物品是什么，保证查询的柜子有存过东西。

已知超市里共计不会超过 $10^7$ 个寄包格子，$a_i$ 是确定然而未知的，但是保证一定不小于该柜子存物品请求的格子编号的最大值。当然也有可能某些寄包柜中一个格子都没有。

### 思路

显然不能直接开二维数组，有三种方法：

1. 动态 `list.append()` 能过但是时间复杂度高
2. 可以用 `dict` 维护 ((第i个柜子, 第j个格子), 物品)
3. 由于柜子和格子都在 $10^5$ 内，所以可以通过 Hash 把 柜子序号乘 $10^5$ 加 格子序号，然后用 `dict` 维护。

## P1449	后缀表达式

计算后缀表达式

### 思路

栈的模拟

## P1996	约瑟夫问题

依次输出出圈的人的序号

### 思路

使用数组取模或者链表模拟

## P1160	队列安排

链表模拟题

## P1540	\[NOIP2010 提高组\] 机器翻译

模拟一个 LRU 的实现，但是再次命中缓存中的元素不更改优先级。所以用一个队列和数组维护即可。

## P2058	\[NOIP2016 普及组\] 海港

小 K 对这些到达海港的船只非常感兴趣，他按照时间记录下了到达海港的每一艘船只情况；对于第 $i$ 艘到达的船，他记录了这艘船到达的时间 $t_i$ (单位：秒)，船上的乘客数 $k_i$，以及每名乘客的国籍 $x_{i,1}, x_{i,2},\dots,x_{i,k}$。

小K统计了 $n$ 艘船的信息，希望你帮忙计算出以每一艘船到达时间为止的 $24$ 小时（$24$ 小时 $=86400$ 秒）内所有乘船到达的乘客来自多少个不同的国家。

形式化地讲，你需要计算 $n$ 条信息。对于输出的第 $i$ 条信息，你需要统计满足 $t_i-86400 < t_p \le t_i$ 的船只 $p$，在所有的 $x_{p,j}$ 中，总共有多少个不同的数。

### 思路

- 把人到来的时间和国籍放进队列, 去重计数.
- 队列只要记住主时间线之前 86400 秒内的人即可
- 维护一个国籍人数队列 or 字典, 当有人就 `ans+=1`

## P1241	括号序列

### 题意翻译与思路

- 扫描一遍原序列，当找到一个右括号时，以它为起点向左找，找到一个没被标记成功匹配的左括号，如果两者匹配的话，标记它们成功匹配; 如果不匹配，或者找不到左括号的话，不做任何标记。
- 扫描一遍标记完成功匹配的括号之后，扫描一遍序列，对于标记过的括号，则直接输出；对于没有标记的括号，则补全成对输出

## P4387	【深基15.习9】验证栈序列

给两个序列, 第一个是入栈序列, 需要判断第二个序列是否是可能的出栈序列.

### 思路

栈的模拟，如果**出栈序列的当前元素已在栈中但不在栈顶**，则出栈序列不合法，否则压栈直到出栈序列的当前元素位于栈顶，然后出栈，考虑序列的下一个元素。时间复杂度 $O(n)$

## P2234	\[HNOI2002\] 营业额统计

要求除第一个数之外输入数据的前驱（比它小的数之最大值）和后继（比它小的数之最小值）

### 思路

- C++ 中可以使用 `lowerbound` 和 `map` 实现 $O(logn)$ 的插入和查询
- Python 的 `dict` 原理是 Hash, 所以不能用二分查找. 本题年代久远, 可以用 `list` 维护一个有序列表, 插入时间复杂度 $O(n)$, 查找时间复杂度 $O(logn)$, 数据水所以也可以过.

```python
import sys
input = sys.stdin.readline
import bisect

n = int(input())
a = int(input())
alist = [-1e7,a,1e7]
ans = a
for i in range(1,n):
    a = int(input())
    j = bisect.bisect_left(alist,a)
    if alist[j] == a:
        continue
    ans += min(a-alist[j-1],abs(alist[j]-a))
    alist.insert(j,a)
print(ans)
```
