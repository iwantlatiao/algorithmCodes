# 1-1 模拟与高精度总结

## P2670 [NOIP2015 普及组] 扫雷游戏

简单模拟，输入地雷地图，输出地雷分布情况

可以通过在地图外围一圈障碍表示边界，减少判断：

```python
# 地图的范围是(1,1)~(n,m)，围上一圈"?"
x = [["?" for _ in range(m + 2)]]
for i in range(n):
    s = list(input())
    x.append(["?"] + s + ["?"])
x.append(["?" for _ in range(m + 2)])
```

## P1563 [NOIP2016 提高组] 玩具谜题

简单模拟

## P4924 魔法少女小Scarlet

关于旋转数组的简单模拟。如果将旋转数组的中心作为参考点将更为方便。

在本目录中的解法将旋转中心的左上角作为参考点，同时操作常数较大，python 会 TLE，懒得改了。

## P1518 \[USACO2.4\] 两只塔姆沃斯牛 The Tamworth Two

关于农夫抓牛的简单模拟，需要使用 Hash 判断死循环的情况：

```python
boolMap = [False for _ in range(170000)]
# ...
boolMapValue = (
    farmerCoor[0]
    + farmerCoor[1] * 10
    + coWCoor[0] * 100
    + coWCoor[1] * 1000
    + farmerCoor[2] * 10000
    + coWCoor[2] * 40000
)
if boolMap[boolMapValue]:
    print("0")
    quit(0)
else:
    boolMap[boolMapValue] = True
```
## P1098 [NOIP2007 提高组] 字符串的展开

简单模拟，注意题目中的特殊条件。

-  `ord()` : char to ASCII
-  `chr()` : ASCII to char

## P1065 [NOIP2006 提高组] 作业调度方案

题意复杂，总的来说有三个约束条件：

1. 每个工件的下一个工序必须在上一个工序之后
2. 同一台机器同一时刻只能加工一个工件
3. 按题目顺序安排下一个工件

理解后的模拟思路是：

- 按照题目给出的工件处理顺序进行扫描
- 维护第 i 个工件的最后加工时间和第 i 个机器的第 j 个时段是否空闲
- 从本工件的最后加工时间开始往后扫描时间，直到找到一个能完全容纳的空闲时间段

## P1786 帮贡排序

题目大意为需要进行两次排序，第一次排序用帮贡值和输入顺序，第二次排序用职位、等级和输入顺序。

python 中自带 `sorted` 方法可以方便快速实现排序。还可以用 `key=lambda x : (x[1], -x[2], ...)` 实现基于多个值的排序。

## P1249 最大乘积

题目：将指定的正整数 n 分解成若干个互不相同的自然数的和，且使这些自然数的乘积最大。

思路：
- 分为尽可能多的数，所以可以分成 2, 3, ..., m，且 2+...+m 刚好大于等于 n
- 如果等于 n，则此方案最优；如果等于 n+1，则将 m 加 1，去掉 2；否则去掉相应的数字即可

## P1045 [NOIP2003 普及组] 麦森数

题目：输入 P (P<3100000) 计算 $2^P-1$ 的位数和最后 500 位数字

思路：
- 因为 $2^P$ 最后一位不是 0，所以 $2^P-1$ 和 $2^P$ 位数相同，然后计算位数
- 设 $2^P$ 的位数为 $k$ 则有 $10^{k-1} < 2^P < 10^k$，故 $k-1 < log_{10}(2^P) < k$，即 $k=\lceil P\times log_{10}2 \rceil$
- 快速计算 $2^P$ 需要使用高精度，但 python 自带 pow 函数和高精度，所以简单调用函数即可。